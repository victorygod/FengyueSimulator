帮我用python写一个简单的同时支持pc本地web和android apk的项目，要求在本地运行，页面需求为一个聊天窗口，仅包含一个输入框和聊天历史和一些按钮。当我发送消息后，系统把我这次发送的消息显示在聊天历史，然后再调用deepseek api流式回复我。

项目结构如下：
ChatApp/
├── main.py                 # 统一入口文件
├── chat_core.py            # 重构的核心聊天逻辑
├── platform_web.py         # 业务无关的Web平台实现
├── platform_android.py     # 业务无关的Android平台实现
├── api_registry.py         # API路由注册中心
├── prompts/                # 提示词管理
│   ├── default_prompt.json # 默认提示词配置
│   └── *.json             # 其他提示词文件
├── config/                 # 配置管理
│   └── api_key.json       # API密钥存储
├── frontend/               # 前端代码
│   ├── index.html
│   ├── style.css
│   └── app.js              # 统一前端JavaScript
├── resource/               # 图片资源文件夹
└── save/                   # 数据存储文件夹
    ├── autosave.json       # 当前自动保存
    ├── autosave_1.json     # 历史存档1
    ├── autosave_2.json     # 历史存档2
    └── *.json             # 手动存档文件

以下是platform_web.py的代码（可能有bug，生成代码的时候帮我调试一下）：
#!/usr/bin/env python3
"""
业务无关的Web平台实现
使用API注册中心处理所有请求，完全与业务逻辑解耦
"""
import os
import webbrowser
from http.server import HTTPServer, SimpleHTTPRequestHandler
from urllib.parse import urlparse, parse_qs
import json

# 导入API注册中心
from api_registry import api_registry


class WebChatHandler(SimpleHTTPRequestHandler):
    """Web聊天请求处理器"""
    
    def __init__(self, *args, **kwargs):
        self.api_registry = api_registry
        super().__init__(*args, **kwargs)
    
    def do_GET(self):
        """处理GET请求"""
        parsed_path = urlparse(self.path)
        
        # API路由
        if parsed_path.path.startswith('/api/'):
            self.handle_api_request(parsed_path.path, 'GET')
            return
        
        # 静态文件路由
        directory, relative_path = self.api_registry.get_static_route(parsed_path.path)
        if directory:
            # 设置静态文件目录
            self.directory = directory
            if relative_path == '' or relative_path == '/':
                self.path = '/index.html'
            else:
                self.path = relative_path
            return super().do_GET()
        
        # 默认404
        self.send_error(404, "文件不存在")
    
    def do_POST(self):
        """处理POST请求"""
        parsed_path = urlparse(self.path)
        
        if parsed_path.path.startswith('/api/'):
            self.handle_api_request(parsed_path.path, 'POST')
        else:
            self.send_error(404, "接口不存在")
    
    def handle_api_request(self, path: str, method: str):
        """处理API请求"""
        # 提取endpoint
        endpoint = path[len('/api/'):]
        
        try:
            # 解析请求数据
            data = None
            if method == 'POST':
                content_length = int(self.headers['Content-Length'])
                post_data = self.rfile.read(content_length).decode('utf-8')
                
                # 尝试解析为JSON
                try:
                    data = json.loads(post_data)
                except json.JSONDecodeError:
                    # 回退到表单数据解析
                    data = parse_qs(post_data)
                    # 简化数据格式
                    simplified_data = {}
                    for key, value in data.items():
                        simplified_data[key] = value[0] if value else ''
                    data = simplified_data
            
            # 调用API处理器
            response = self.api_registry.handle_request(endpoint, method, data)
            
            # 发送响应
            self.send_json_response(response)
            
        except Exception as e:
            self.send_error(500, f"服务器错误: {str(e)}")
    
    def send_json_response(self, data):
        """发送JSON响应"""
        self.send_response(200)
        self.send_header('Content-type', 'application/json; charset=utf-8')
        self.end_headers()
        self.wfile.write(json.dumps(data).encode('utf-8'))


class WebPlatform:
    """Web平台实现"""
    
    def __init__(self, chat_bot):
        self.chat_bot = chat_bot
        self.port = 8000
    
    def start(self):
        """启动Web服务器"""
        # 注册API
        from api_registry import register_chat_apis
        register_chat_apis(self.chat_bot)
        
        # 创建自定义请求处理器
        def handler_factory(*args, **kwargs):
            return WebChatHandler(*args, **kwargs)
        
        # 启动服务器
        server = HTTPServer(('localhost', self.port), handler_factory)
        
        print(f"聊天服务器已启动，访问 http://localhost:{self.port}")
        print("按 Ctrl+C 停止服务器")
        
        # 自动打开浏览器
        try:
            webbrowser.open(f'http://localhost:{self.port}')
        except:
            print("无法自动打开浏览器，请手动访问上述地址")
        
        try:
            server.serve_forever()
        except KeyboardInterrupt:
            print("\n服务器已停止")
            server.shutdown()

以下是platform_android.py的代码（可能有bug，生成代码的时候帮我调试一下）：
#!/usr/bin/env python3
"""
业务无关的Android平台实现
使用API注册中心处理所有请求，完全与业务逻辑解耦
"""
import os
import json
from http.server import HTTPServer
from threading import Thread

# 导入API注册中心
from api_registry import api_registry


class AndroidHttpHandler:
    """Android HTTP请求处理器"""
    
    def __init__(self, api_registry):
        self.api_registry = api_registry
    
    def handle_request(self, path: str, method: str, body: str = None):
        """处理HTTP请求"""
        # 提取endpoint
        if path.startswith('/api/'):
            endpoint = path[len('/api/'):]
            
            # 解析请求数据
            data = None
            if body:
                try:
                    data = json.loads(body)
                except json.JSONDecodeError:
                    # 简化处理表单数据
                    from urllib.parse import parse_qs
                    parsed_data = parse_qs(body)
                    simplified_data = {}
                    for key, value in parsed_data.items():
                        simplified_data[key] = value[0] if value else ''
                    data = simplified_data
            
            # 调用API处理器
            return self.api_registry.handle_request(endpoint, method, data)
        
        # 静态文件路由
        directory, relative_path = self.api_registry.get_static_route(path)
        if directory:
            # 这里简化处理，实际Android应用中需要特殊处理静态文件
            return {"status": "static", "directory": directory, "path": relative_path}
        
        return {"status": "error", "message": "路径不存在"}


class AndroidPlatform:
    """Android平台实现"""
    
    def __init__(self, chat_bot):
        self.chat_bot = chat_bot
        self.port = 8080
        self.api_registry = api_registry
    
    def start(self):
        """启动Android应用"""
        try:
            from kivy.app import App
            from kivy.uix.boxlayout import BoxLayout
            from kivy.uix.webview import WebView
            
            # 注册API
            from api_registry import register_chat_apis
            register_chat_apis(self.chat_bot)
            
            # 创建HTTP处理器
            http_handler = AndroidHttpHandler(self.api_registry)
            
            class ChatWebView(WebView):
                def __init__(self, http_handler, **kwargs):
                    super().__init__(**kwargs)
                    self.http_handler = http_handler
                
                def handle_api_request(self, endpoint, method, data=None):
                    """处理API请求"""
                    return self.http_handler.handle_request(f'/api/{endpoint}', method, json.dumps(data) if data else None)
            
            class ChatAppLayout(BoxLayout):
                def __init__(self, platform, **kwargs):
                    super().__init__(**kwargs)
                    self.orientation = 'vertical'
                    self.platform = platform
                    
                    self.webview = ChatWebView(platform.http_handler)
                    self.add_widget(self.webview)
                    
                    self.setup_javascript_bridge()
                    self.load_html_interface()
                
                def setup_javascript_bridge(self):
                    """设置JavaScript桥接"""
                    @self.webview.bind(js_api=self)
                    def AndroidBridge(instance, value):
                        return self
                    
                    def apiRequest(endpoint, method, data):
                        """处理API请求"""
                        try:
                            result = self.webview.handle_api_request(endpoint, method, data)
                            return json.dumps(result)
                        except Exception as e:
                            return json.dumps({
                                "status": "error",
                                "message": f"请求处理失败: {str(e)}"
                            })
                    
                    self.apiRequest = apiRequest
                
                def load_html_interface(self):
                    """加载HTML界面"""
                    html_path = os.path.join('frontend', 'index.html')
                    with open(html_path, 'r', encoding='utf-8') as f:
                        html_content = f.read()
                    self.webview.load_html(html_content)
            
            class ChatApp(App):
                def __init__(self, platform, **kwargs):
                    super().__init__(**kwargs)
                    self.platform = platform
                
                def build(self):
                    self.title = "增强版聊天机器人"
                    return ChatAppLayout(self.platform)
                
                def on_pause(self):
                    return True
                
                def on_resume(self):
                    pass
            
            # 启动本地HTTP服务器
            self.start_http_server()
            
            # 启动Kivy应用
            ChatApp(self).run()
            
        except ImportError as e:
            print("错误: 缺少Android应用依赖")
            print("请安装: pip install kivy")
            print("或在Android环境中运行")
    
    def start_http_server(self):
        """启动HTTP服务器（用于资源文件服务）"""
        # 这里简化处理，实际Android应用中资源文件应该打包到APK中
        # 或者使用Kivy的资源管理机制
        print("Android平台: 资源文件服务已启用")

其他需求：
platform_*需要彻底业务无关，比如endpoit的解析（即api路由）完全可以通过api_registry.py里的逻辑在platform_*中注册，这样当新增api时，我们只需要改api_registry和前端，不用改platform_*。
chat_core里会根据我的输入，拼到聊天历史里作为提示词，调用deepseek api生成回复，新增到聊天历史。
默认提示词存储在prompts/default_prompt.json里（json包含以下field：name,pre_prompt, pre_text, post_text，分别用来做提示词名字（无实际意义），主提示词，每次我说的话的前缀和后缀。）, 并且界面支持我选择/修改/新建/复制/删除/重命名不同的提示词文件。修改后，重新加载提示词和当前聊天历史，继续聊天。
api_key一开始为空，在界面上添加按钮让我能够查看并修改api_key，然后存在本地。（下次打开app或网页就自动读取本地存的api_key，和config.json一样）；
对于save目录下的聊天历史，在保存时需要支持新建/覆盖存档文件（点到一个已存在的存档就提示我是否覆盖），在加载时需要支持删除/加载存档。autosave功能会保留进5次存档，每次deepseek流式回复结束就自动保存，例如：每次deepseek回复完毕，都会先将autosave_5删掉（如有），autosave_4重命名为autosave_5, autosave_3重命名为autosave_4……autosave重命名为autosave_1,然后把当前聊天历史存入新建的autosave文件。重新打开app或界面，自动加载autosave，并将内容显示到界面上。
检测deepseek回复的内容，如果出现了某个resource目录下的图片的文件名则在deepseek回复结束后，回复一张这个图片。
增加针对resource目录下的图片的文档管理功能，并增加从其他目录下复制文件到resource目录下的功能。
文档管理功能模块可以整合起来，和api_key管理，存档管理等功能合并(增删改查等功能都是通用的)。尽可能使代码简洁，并具有可读性。

当api密钥为空时，弹框提示我请先设置api密钥，而不是在聊天窗口里显示一条回复。
存档页面选中某一存档，新存档名称自动变成该存档名字。如果新存档名字已经存在，弹框提示我是否覆盖。
所有的删除操作都需要弹框让我确认。
资源管理对话框，增加图片预览窗口，选中某个文件就在预览窗口处显示图片预览。
存档、资源、提示词、api密钥对话框均需要支持重命名操作。


将保存/自动保存/加载/获取资源文件列表/复制文件到资源目录/删除文件/加载删除提示词等与构造聊天内容无关的功能从chat_core.py中剥离出来，形成一个新文件：storage_manager，专门负责这些事情。
resource目录下的文件名需要支持中文文件名
对话框布局需要优化一下，图片预览窗口位置太小了，而左侧有大量空白，请合理安排布局。

把当前页面的title和<h1></h1>中的内容替换成当前选中的提示词文件的name字段。
界面上新增记忆轮数的设定，这个设定用来控制每次最多把多少轮以前的聊天记录一起发给deepseek。
让提示词、api_key、存档的管理页面里输入名字或显示名字时都带上后缀名，尤其是新建文件或重命名时，让我完整输入带有后缀名的文件名字
在config文件夹下新增用户偏好文件，主要存储用户上一次使用习惯的设定，目前仅包括使用的提示词文件名，记忆轮数。如果文件不存在，先用默认值（记忆轮数6，提示词文件名default_prompt.json）新建一个user_preferences，然后再加载。
把storage_manager.py文件中的方法整合缩减，比如重命名文件、删除文件等操作完全可以只写一个方法。

界面上的记忆轮数去掉设置按钮，失焦则更新。
title和<h1></h1>中的内容不是要替换成提示词文件的文件名，而是提示词json的name字段


chat_core.py中的两个函数改成这样：
    def build_messages(self, user_input: str) -> List[Dict[str, str]]:
        """构建消息列表，考虑记忆轮数"""
        messages = []
        
        # 添加系统提示词
        if self.prompt_config.get('pre_prompt'):
            messages.append({
                "role": "system",
                "content": self.prompt_config['pre_prompt']
            })
        
        # 添加历史对话（考虑记忆轮数）
        if self.memory_rounds > 0:
            # 计算需要保留的历史消息数量
            max_messages = self.memory_rounds 
            recent_history = self.chat_history[-max_messages:] if max_messages > 0 else self.chat_history
        else:
            # 如果记忆轮数为0，只使用系统提示词
            recent_history = []
        
        for msg in recent_history:
            messages.append(msg)
        
        # 添加当前用户输入
        pre_text = self.prompt_config.get('pre_text', '')
        post_text = self.prompt_config.get('post_text', '')
        user_message = f"{pre_text}{user_input}{post_text}"
        
        messages.append({
            "role": "user",
            "content": user_message
        })
        
        return messages
    
    def stream_chat(self, user_input: str) -> Generator[str, None, None]:
        """流式聊天"""
        if not self.api_key:
            raise Exception("请先设置API密钥")
        
        try:
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Bearer {self.api_key}"
            }
            
            data = {
                "model": "deepseek-chat",
                "messages": self.build_messages(user_input),
                "stream": True
            }
            print(data)
            response = requests.post(
                self.base_url,
                headers=headers,
                json=data,
                stream=True,
                timeout=30
            )
            
            if response.status_code != 200:
                error_msg = f"API请求失败: {response.status_code} - {response.text}"
                raise Exception(error_msg)
            
            assistant_response = ""
            for line in response.iter_lines():
                if line:
                    line = line.decode('utf-8')
                    if line.startswith('data: '):
                        data_str = line[6:]
                        if data_str == '[DONE]':
                            break
                        try:
                            data_json = json.loads(data_str)
                            if 'choices' in data_json and len(data_json['choices']) > 0:
                                delta = data_json['choices'][0].get('delta', {})
                                if 'content' in delta:
                                    content = delta['content']
                                    assistant_response += content
                                    yield content  # 直接返回内容，不添加换行
                        except json.JSONDecodeError:
                            continue

            # 添加用户消息到历史
            self.chat_history.append({
                "role": "user",
                "content": user_input
            })
            
            # 添加助手回复到历史
            self.chat_history.append({
                "role": "assistant",
                "content": assistant_response
            })
            
            # 检测并处理图片
            image_files = self.detect_images_in_response(assistant_response)
            for image_file in image_files:
                yield f"\n[图片: {image_file}]"
            
            # 自动保存
            self.auto_save()
            
        except Exception as e:
            raise Exception(f"聊天失败: {str(e)}")

提示词页面需要让我能够编辑提示词json的name字段。
刚打开页面的时候，<h1>里显示的是“默认提示词”，而不是从autosave文件里加载出来的提示词json的name字段内容。请分析为什么会这样并给出解决方案。


完整输出每个文件的内容。
所有交互和通信都需要支持中文。
在android上运行前，用Buildozer打包成apk